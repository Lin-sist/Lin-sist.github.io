---
title: RAG知识汇总
tags: [RAG]
date: 2026-02-14
---


# RAG（检索增强生成）技术详解

## 1. 什么是 RAG？

RAG（Retrieval-Augmented Generation，检索增强生成）是一种结合了**信息检索**和**文本生成**的 AI 技术架构。

### 1.1 核心思想

传统的大语言模型（LLM）依赖于训练时学到的知识，但存在以下问题：

- **知识截止**：只知道训练时的数据

- **幻觉问题**：可能生成不准确的内容

- **缺乏专业知识**：无法回答企业内部或专业领域问题

  

**RAG 的解决方案**：

1. 先从知识库中**检索**相关信息

2. 将检索到的信息作为**上下文**提供给 LLM

3. LLM 基于上下文生成**准确的答案**


## 2. RAG 架构流程
  

```

用户提问 → 向量化 → 向量检索 → 召回相关文档 → 构建提示词 → LLM 生成答案 → 返回结果

```


### 2.1 详细步骤


#### Step 1: 文档处理（离线）

1. **文档上传**：PDF、Markdown、Word、代码文件等

2. **文档解析**：提取文本内容

3. **文本分块**：将长文档切分为小块（Chunk），通常 500-2000 字符

4. **向量化**：使用 Embedding 模型将文本转换为向量

5. **存储**：向量存入向量数据库（Milvus、Pinecone 等）

  

#### Step 2: 问答处理（在线）

1. **问题向量化**：用户问题转换为向量

2. **相似度检索**：在向量数据库中搜索最相似的文本块（Top-K）

3. **构建提示词**：将检索到的内容和问题组合成 Prompt

4. **LLM 生成**：调用大模型生成答案

5. **返回结果**：返回答案和引用来源

  

## 3. 核心技术

### 3.1 Embedding（嵌入/向量化）

将文本转换为高维向量，语义相似的文本向量距离更近。
  

**常用模型**：

- **OpenAI text-embedding-ada-002**：1536 维

- **BGE 系列**（中文优化）：bge-large-zh、bge-small-zh

- **通义千问 Embedding**：text-embedding-v1


**示例**：

```

"Java 是一种编程语言" → [0.12, -0.34, 0.56, ..., 0.89] (1536 维向量)

"Python 是编程语言" → [0.15, -0.31, 0.52, ..., 0.91] (相似度高)

"今天天气很好" → [-0.78, 0.23, -0.45, ..., 0.12] (相似度低)

```
  

### 3.2 向量数据库

专门存储和检索向量的数据库，支持高效的相似度搜索。
  

**常用数据库**：

- **Milvus**：开源，性能强，本项目使用

- **Pinecone**：托管服务

- **Weaviate**：支持混合搜索

- **Qdrant**：Rust 实现
  

**检索算法**：

- **HNSW**（层次化可导航小世界图）：召回率高，速度快

- **IVF**（倒排索引）：适合大规模数据

- **FLAT**（暴力搜索）：精度最高但速度慢
  

### 3.3 文本分块策略
  

**为什么需要分块？**

- LLM 有 Token 限制（GPT-3.5 是 4096，GPT-4 是 8192/32768）

- 小块检索更精准

- 提高检索效率
  

**分块方法**：

1. **固定长度分块**：每 500 字符一块

2. **句子/段落分块**：自然语言边界

3. **滑动窗口**：重叠分块，避免语义割裂

4. **语义分块**：使用 NLP 技术识别语义边界
  

**示例**：

```

原文档（2000 字）

↓ 分块

Chunk 1（500 字）：介绍部分

Chunk 2（500 字）：技术原理

Chunk 3（500 字）：应用场景

Chunk 4（500 字）：总结

```

  

## 4. 提示词工程（Prompt Engineering）

RAG 系统需要精心设计提示词，将检索到的上下文和问题结合。
  

### 4.1 典型 Prompt 模板

```
你是一个专业的技术助手。请根据以下文档内容回答用户的问题。

【相关文档】

{retrieved_context}

【用户提问】

{user_question}
  
【回答要求】

1. 基于文档内容回答，不要编造信息

2. 如果文档中没有相关信息，明确说明

3. 引用具体的文档片段作为依据

4. 回答要简洁清晰
  
请回答：
```

  

### 4.2 优化技巧

- **明确角色**：定义 AI 的身份（技术助手、客服等）

- **提供约束**：禁止编造、要求引用来源

- **Few-Shot**：提供示例问答

- **Chain of Thought**：要求逐步推理

  

## 5. 性能优化

  

### 5.1 检索优化

- **混合检索**：向量检索 + 关键词检索（BM25）

- **重排序（Rerank）**：二次精排，提高准确率

- **Query 改写**：扩展或改写用户问题，提高召回

  

### 5.2 缓存策略

- **问题缓存**：相同问题直接返回缓存结果

- **向量缓存**：缓存常见问题的向量

  

### 5.3 评估指标

- **检索准确率**：Top-K 是否包含正确答案

- **答案质量**：人工评分或自动评估（ROUGE、BLEU）

- **延迟**：端到端响应时间

  

## 6. 常见问题

  

### Q1: RAG vs 微调（Fine-tuning）？

| 对比项 | RAG | 微调 |

|--------|-----|------|

| 知识更新 | 实时更新文档即可 | 需要重新训练 |

| 成本 | 低（只需 API 调用） | 高（需要 GPU 训练） |

| 可解释性 | 高（可追溯来源） | 低 |

| 专业能力 | 适合知识密集型 | 适合特定任务 |

  

**最佳实践**：RAG + 微调结合使用。

  

### Q2: 如何提高 RAG 准确率？

1. **优化分块策略**：合理设置 Chunk 大小

2. **提升 Embedding 质量**：选择合适的模型

3. **增加 Top-K**：检索更多候选

4. **使用 Rerank**：二次精排

5. **优化 Prompt**：明确回答要求

  

### Q3: 向量数据库如何选择？

- **小规模**（< 100 万向量）：Qdrant、Weaviate

- **大规模**（> 100 万向量）：Milvus、Pinecone

- **本地部署**：Milvus、Qdrant

- **云服务**：Pinecone、Weaviate Cloud

  

## 7. 实际应用场景

  

### 7.1 企业知识库问答

- **场景**：公司内部文档、规章制度、技术文档

- **优势**：新员工快速了解公司知识

  

### 7.2 客服机器人

- **场景**：产品手册、常见问题、售后政策

- **优势**：24/7 自动回答，降低人工成本

  

### 7.3 智能编程助手

- **场景**：代码库、API 文档、技术博客

- **优势**：快速查找代码示例、技术方案

  

### 7.4 法律文书检索

- **场景**：法律条文、判例、合同模板

- **优势**：精准检索相关法条

  

## 8. 技术栈示例（本项目）

  

```
前端：用户提问
↓
Spring Boot 后端
↓
文档处理层：解析、分块
↓
Embedding 服务：向量化（通义千问 API）
↓
Milvus 向量数据库：存储和检索
↓
LLM 服务：生成答案（通义千问 Qwen-Turbo）
↓
返回答案 + 引用来源
```

  

## 9. 面试常见问题

  

### Q1: 为什么需要向量化？

**A**: 传统的关键词匹配无法理解语义。例如：

- 问题："如何学习 Java？"

- 文档："Java 学习指南"

- 关键词匹配：匹配到"Java"和"学习"

- 向量匹配：理解"如何学习"和"学习指南"语义相似

  

### Q2: Chunk 大小如何选择？

**A**:

- **太小**（< 200 字符）：语义不完整

- **太大**（> 2000 字符）：检索不精准，耗费 Token

- **推荐**：500-1000 字符，根据文档类型调整

- **技术文档**：按段落或章节分块

- **代码文档**：按函数或类分块

  

### Q3: 如何评估 RAG 系统效果？

**A**:

1. **离线评估**：准备测试问答对，计算准确率

2. **在线评估**：A/B 测试，收集用户反馈

3. **关键指标**：

- 检索召回率：Top-K 包含正确答案的比例

- 答案准确率：生成答案的正确性

- 用户满意度：点赞率、采纳率

  

---

  

**RAG 是 AI 应用的核心技术之一，掌握它能大大提升你的竞争力！🚀**